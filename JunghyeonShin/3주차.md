# 02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다

데이터 송·수신은 아래와 같은 순서로 동작한다.
1. 소켓을 작성하는 단계
2. 접속 동작 실행 단계
3. 데이터 송·수신 단계
4. 연결 끊기 단계

데이터 송·수신을 자세하게 알아보기 전에 OS에 내장된 네트워크 제어용 소프트웨어(프로토콜 스택)와 네트워크용 하드웨어(LAN 어뎁터)가 브라우저에서 받은 메시지를 서버에 송출하는 동작을 알아보자.

![TCP/IP 소프트웨어의 계층 구조](./Image/Image09.png)

먼저 맨 위에 있는 것은 네트워크 애플리케이션으로 브라우저, 메일러, 웹 서버, 메일 서버 등의 프로그램 등이 있다. 데이터의 송·수신 등의 일을 의뢰하며 애플리케이션의 아랫부분에는 Socket 라이브러리와 리졸버가 있다.

그 아래가 OS의 내부이며, 여기에 프로토콜 스택이 있다. TCP와 UDP 프로토콜을 사용하여 데이터 송·수신을 담당한다. 브라우저, 메일 등의 일반적인 애플리케이션에서 사용할 때는 TCP를 사용하고, DNS 서버에 대한 조회 등에서 짧은 제어용 데이터를 송·수신하는 경우 UDP를 사용한다.

그 아래에는 패킷 송·수신 동작을 제어하는 IP가 있다. 패킷이란 작은 덩어리로 분할된 데이터를 말하며, 이 패킷을 통신 상대까지 운반하는 것이 IP의 주 역할이다. 그리고 IP 내부에는 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메시지를 통지하는 **ICMP**(Internet Control Message Protocol) 프로토콜과 IP 주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용하는 **ARP**(Address Resolution Protocol) 프로토콜을 다룬다.

IP 아래에는 LAN 드라이버와 LAN 어뎁터가 있으며 LAN 드라이버는 LAN 어뎁터의 하드웨어를 제어하고 실제 송·수신 동작을 LAN 어뎁터가 실행한다.

------------
그럼 이제 데이터 송·수신 동작을 하나씩 알아보자.

![메시지 송신 동작](./Image/Image10.png)

먼저 소켓에 대해 알아보자. 프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있으며, 통신 상대의 IP 주소, 포트 번호, 통신 동작이 어떤 진행 상태에 대한 정보가 담겨있다.
<br>소켓은 이런 제어 정보 또는 제어 정보를 기록한 메모리 영역을 말한다. 소켓의 역할은 통신 동작을 제어하기 위한 여러 가지 제어 정보를 통해 프로토콜 스택이 다음에 무엇을 해야하는지 판단한다.

애플리케이션이 socket을 호출하여 소켓을 만들 것을 의뢰하면 프로토콜 스택은 의뢰에 따라 한 개의 소켓을 만든다.
> <디스크립터> = socket(<IPv4 사용>, <TCP 사용>,...);

이때 프로토콜 스택은 소켓 한 개 분량의 메모리 영역을 확보하고 여기에 제어 정보를 기록한다. 또한 초기 상태임을 나타내는 제어 정보를 소켓의 메모리 영역에 기록한다. 이렇게 소켓이 만들어지면 소켓을 나타내는 **디스크립터**를 애플리케이션에 알려준다.

## 2. 서버에 접속한다
클라이언트측의 소켓을 서버측의 소켓에 접속하는 단계
- 접속한다는 것
	- 프로토콜 스택이 어떻게 움직이는지
	- 서버와 어떤 대화를 하는지
### 1 접속의 의미
- 애플리케이션은 connect를 호출
	- 프로토콜 스택은 자기쪽의 소켓을 서버측 소켓에 접속
	- 접속 동작
		- 서버의 IP 주소나 포트 번호를 프로토콜 스택에 알리는 동작
		- 클라이언트측에서 서버측에 통신 동작의 개시를 전달
			- 통신하려는 클라이언트가 있다는 것을 서버측에 전달하고 서버측의 프로토콜 스택도 클라이언트의 정보를 가질 수 있음
		- 첫 번째 동작은 통신 상대와의 사이에 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송·수신이 가능한 상태로 만드는 것
		- 데이터 송·수신 동작을 실행할 때는 송·수신하는 데이터를 일시적으로 저장하는 버퍼 메모리의 확보

### 2 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다
- 제어 정보는 두 종류가 있다.
	- 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 제어 정보
		- 접속 동작뿐만 아니라 데이터를 송·수신하는 동작이나 연결을 끊는 동작도 포함
		- TCP 프로토콜의 사양으로 규정
		- 제어 정보를 패킷의 맨 앞부분에 배치하는 곳부터 헤더라고 부름
	- 소켓에 기록하여 프로토콜 스택의 동작을 제어하기 위한 제어 정보
		- 애플리케이션에서 통지된 정보, 통신 상대로부터 받은 정보 등이 수시로 기록

### 3 접속 동작의 실제
connect(<디스크립터>, <서버측의 IP 주소와 포트번호>,...);
- 먼저 데이터 송·수신 동작의 개시를 나타내는 제어 정보를 기록한 헤더를 만듦
	- 송신처가 되는 클라이언트측의 소켓과 수신처가 되는 서버측의 소켓을 지정할 수 있음
- IP 담당 부분에 건네주어 송신하도록 의뢰
	- IP 담당 부분이 패킷 송신 동작을 실행하고 네트워크를 통해 패킷이 서버에 도착하면 서버측의 IP 담당 부분이 이것을 받아 TCP 담당 부분에 건네줌
	- 서버측의 TCP 담당 부분이 TCP 헤더를 조사하여 기록되어 있는 수신처 포트 번호에 해당하는 소켓을 찾아냄
	- 해당하는 소켓이 발견되면 여기에 필요한 정보를 리고하고 접속 동작이 진행중이라는 상태가 됨
	- 서버측의 TCP 담당 부분은 응답을 돌려보냄
- 패킷이 클라이언트에 돌아오고 IP 담당 부분을 경유하여 TCP 담당 부분에 도착
	- TCP 헤더를 조사하여 서버측의 접속 동작이 성공했는지 확인
- 패킷이 도착한 것을 서버에 알리기 위해 TCP 헤더를 반송

## 3. 데이터를 송·수신한다
소켓이 연결되면 메시지를 송신하는 단계
- 메시지를 작은 조각으로 분할하여 서버를 향해 송신
- 오류 때문에 패킷이 없어진다고 가상하여 분할한 조각이 제대로 서버측에 도착했는지 확인하고, 도착하지 않았으면 다시 한 번 보냄
### 1 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다
write(<디스크립터>, <송신 데이터>, <송신 데이터 길이>);
- 애플리케이션에 제어가 되돌아오면 write를 호출하여 송신 데이터를 프로토콜 스택에 건네줌
	- 몇 가지 중요한 점이 있음
		- 애플리케이션에서 한 번의 송신 의뢰에서 건네주는 데이터의 길이를 제어
		- 프로토콜 스택은 받은 데이터를 송신용 버퍼 메모리 영역에 저장
		- 어느 정도 데이터를 저장하고 나서 송·수신 동작을 실행
			- OS의 종류나 버전에 따라 달라지지만 다음과 같은 요소를 바탕으로 판단
				- 한 패킷에 저장할 수 있는 데이터의 크기
				- MTU : 한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이
					이더넷 : 1,500 바이트
				- MSS : 헤더를 제외한 데이터의 최대 길이
		- 송신 타이밍
			- 프로토콜 스택은 내부에 타이머가 있어서 이것으로 일정 시간 이상 경과하면 패킷을 송신

### 2 데이터가 클 때는 분할하여 보낸다
- 한 개의 패킷에 들어가지 않을 만큼 긴 데이터를 보낼 경우 맨 앞부터 차례대로 MSS의 크기에 맞게 분할하고, 분할한 조각을 한 개씩 패킷에 넣어 송신

### 3 ACK 번호를 사용하여 패킷이 도착했는지 확인한다
- TCP에는 송신한 패킷이 상대에게 올바르게 도착했는지 확인하고, 도차하지 않았으면 다시 송신하는 기능을 통해 송신 확인을 함
- 확인 방법의 개념
	- 데이터를 조각으로 분할할 때 조각이 통신 개시부터 따져서 몇 번째 바이트에 해당하는지를 세어둠
	- 데이터의 조각을 송신할 때 세어둔 값을 TCP 헤더에 기록하는데, 시퀀스 번호라는 항목이 해당됨
	- 수신측에서 패킷 전체의 길이에어 헤더 길이를 빼는 방법으로 데이터의 크기를 산출하고 이를 통해 패킷이 누락되었는지 확인
	- 수신측은 이전에 수신한 데이터와 합쳐 데이터를 몇 번째 바이트까지 수신한 것인지 계산하고, 그 값은 TCP 헤더의 ACK 번호에 기록하여 송신측에 알림
	- 실제로 악의적인 공격에 대비하기 위해 난수를 바탕으로 산출된 초기값으로 시작하고 데이터의 송·수신을 시작하기 전에 초기값을 상대에게 알림
- TCP의 데이터 송·수신 동작은 양방향이므로 클라이언트에서 서버로 향하는 데이터의 흐름과 서버에서 클라이언트로 향하는 두 가지의 데이터 흐름에 대응
- 도중에 케이블이 분리되거나 서버가 다운되는 등의 이유로 TCP가 아무리 다시 보내고 데이터가 도착하지 않는 경우에는 TCP는 회복의 전망이 없는 것으로 보고 데이터 송신 동작을 강제로 종료하고 애플리케이션에 오류를 통지한다.

### 4 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다
- 사내 LAN이라면 수 밀리초 안에 ACK 번호가 돌아오지만, 인터넷의 경우는 혼잡하면 수백 밀리초를 넘는 경우도 있기 때문에 TCP는 대기 시간을 동적으로 변경하는 방법을 취한다.

### 5 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다
- TCP는 윈도우 제어 방식에 따라 송신과 ACK 번호 통지의 동작을 실행
	- 윈도우 제어는 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 방법
	- 수신측의 능력을 초과하는 문제가 생길 수 있음
	- 먼저 수신측에서 송신측에 수신 가능한 데이터 양을 통지하고, 수신측을 이 양을 초과하지 않도록 송신 동작을 실행하여 문제를 해결
	- TCP 헤더의 윈도우 필드에서 빈 공간을 송신측에 알림

### 6 ACK 번호와 윈도우를 합승한다
- ACK 번호와 윈도우 통지를 한 개의 패킷에 합승시켜 통지하여 패킷의 수를 줄임
- ACK 번호 통지가 연속하여 일어나면 최후의 것만 통지하고 도중의 것은 생략
- 윈도우 통지도 연속하여 일어나면 최후의 것만 통지함

### 7 HTTP 응답 메시지를 수신한다
<수신 데이터 길이> = read(<디스크립터>, <수신 버퍼>,...);
- 웹 서버에서 응답 메시지가 돌아오기를 기다리고, 응답 메시지가 돌아오면 그것을 수신함
- 서버에서 돌아오는 응답 메시지를 받기 위해 read 프로그램을 호출하고 read를 경유하여 프로토콜 스택에 제어가 넘어감
- 서버에서 응답 메시지의 패킷이 도착했을 때 프로토콜 스택은 수신 버퍼에서 수신 테이터를 추출하여 애플리케이션에 건네줌
	- 먼저 수신한 데이터 조각과 TCP 헤더의 내용을 조사하여 도중에 데이터가 누락되었는지 검사하고, 문제가 없으면 ACK 번호를 반송
	- 데이터 조각을 수신 버퍼에 일시 보관하고, 조각을 연결하여 데이터를 원래 모습으로 복원한 후 애플리케이션이 지정한 메모리 영역에 옮겨 기록한 후 애플리케이션에 제어를 되돌려줌

## 4. 서버에서 연결을 끊어 소켓을 말소한다.
메시지 송·수신이 전부 끝나면 서버에서 연결을 끊고 소켓을 말소
### 1 데이터 보내기를 완료했을 때 연결을 끊는다
close(<디스크립터>);
- 데이터 보내기를 완료한 쪽에서 연결 끊기 단계에 들어가는데, 여기에서는 서버측에서 연결 끊기 단계에 들어가는 것으로 간주하고 설명
- 서버측의 애플리케이션이 먼저 Socket 라이브러리의 close를 호출
	- 서버측의 프로토콜 스택이 TCP 헤더를 만들고, 여기에 연결 끊기를 나타내는 정보를 설정
		- 컨트롤 비트의 FIN 비트에 1을 설정하고, IP 담당 부분에 의뢰하여 클라이언트에 송신해 달라고 함
		- 서버측의 소켓에 연결 끊기 동작에 들어갔다는 정보를 기록
- 서버에서 FIN에 1을 설정한 TCP 헤더가 도착하면 클라이언트측의 프로토콜 스택은 자신의 소켓에 서버측이 연결 끊기 동작에 들어갔다는 것을 기록
- 패킷을 받은 사실을 알리기 위해 ACK 번호를 서버측에 반송하고, 애플리케이션이 데이터를 가지러 올 때까지 기다림
- 데이터를 전부 수신 완료하면 클라이언트측의 애플리케이션도 close를 호출하여 데이터 송·수신 동작을 끝냄
- 클라이언트측의 프로토콜 스택은 서버측과 마찬가지로 FIN 비트에 1을 성정한 TCP 헤더를 만들고 IP 담당 부분에 의뢰하여 서버에 송신한 후 서버에서 ACK 번호가 돌아오면 서버와의 대화가 끝남

### 2 소켓을 말소한다
- 오동작을 막기 위해 잠시 기다린 후 소켓을 말소한다

### 3 데이터 송·수신 동작을 정리한다
1. 소켓을 작성하는 단계
2. 접속 동작을 실행
3. 데이터 송·수신 단계
4. 연결 끊기 단계